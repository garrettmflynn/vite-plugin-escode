import { parse } from "@babel/parser";
import babelGenerator from "@babel/generator";
const generate = babelGenerator.default

import fs from 'node:fs'
import options from "../../options";
import { createRelayServer } from "./server";
import http from 'http'

const fileRegex = /\.(flow)$/

const PORT = 40000
try {
    await createRelayServer(PORT) // Set up port once for the server to listen on
} catch { }

export default async function escodeVitePlugin() {
    const virtualModuleId = 'virtual:escode'
    const resolvedVirtualModuleId = '\0' + virtualModuleId

    let mainFile = '';

    return {
        name: 'escode', // required, will show up in warnings and errors

        // Once on Server Start
        options: () => {

        },

        buildStart: () => {

        },

        transformIndexHtml(html) {
            return html.replace(
                /<title>(.*?)<\/title>/,
                `<title>Title replaced!</title>`,
            )
        },

        // Each Incoming Module Request
        resolveId(id) {
            if (id === virtualModuleId) {
                return resolvedVirtualModuleId
            }
        },

        load(id) {
            if (id === resolvedVirtualModuleId) {
                return `

                export const msg = "from virtual module"

                if (import.meta.hot) {

                    import.meta.hot.on('escode:from-server', (data) => console.log(data.msg))

                    import.meta.hot.send('escode:from-client', { message: 'this is arbitrary from the client' })

                }
                
                `
            }
        },

        transform(source, id) {

            const result = { code: source, map: null } // provide source map if available

            if (fileRegex.test(id)) {

                // // Create AST from multiple files
                // const a = "var a = 1;";
                // const b = "var b = 2;";
                // const astA = parse(a, { sourceFilename: "a.js" });
                // const astB = parse(b, { sourceFilename: "b.js" });
                // const ast = {
                //     type: "Program",
                //     body: [].concat(astA.program.body, astB.program.body),
                // };


                const { program: ast } = parse(source, options)


                // Print out the configuration files that are generated by the AST parsers
                fs.writeFileSync('./tmp/ast.json', JSON.stringify(ast, null, 2))

                // return generate(
                //     ast,
                //     { 
                //         sourceMaps: true,
                //         minified: true
                //     },
                //     source
                // )

            }

            // Relay source code link for main file to the editor
            else {
                if (!mainFile || id === mainFile) {
                    result.code = `import.meta.hot.send('escode:from-client', { command: 'update-source', id: "${id}", source: import.meta.url })\n${source}`
                    mainFile = id
                }
            }

            return result
        },

        // Server Closed
        buildEnd: () => {

        },

        closeBundle: () => {

        },

        // Server Communication
        configureServer(server) {

            // Example: wait for a client to connect before sending a message
            server.ws.on('connection', () => server.ws.send('escode:from-server', { msg: 'hello' })) // Send to all clients
            server.ws.on('escode:from-client', (data, client) => {


                var postData = JSON.stringify(data);

                const options = {
                    hostname: 'localhost',
                    port: PORT,
                    path: '/',
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Content-Length': `${postData.length}`
                    }
                }

                const req = http.request(options) //, (res) => res.on('data', (d) => process.stdout.write(d)));
                req.on('error', (e) => console.error(e));
                req.write(postData);
                req.end();

                // client.send('escode:from-server', { msg: "Pong" })
            }) // Use client to only respond to specific client
        },
    }
}